# TODO List - ArchiSchema

## Высокий приоритет

### 1. ✅ Ссылка "Поделиться" в визуальном редакторе + Архитектура LiveShare
**Статус:** ЗАВЕРШЕНО (65/67 задач выполнено, 2 опциональные отложены)

**Проблема:** Ссылка поделиться внутри визуального редактора не переводит пользователя внутрь другого визуального редактора. Необходима полная переработка LiveShare архитектуры по принципам Excalidraw.

#### Фаза 1: Анализ и проектирование
- [x] 1.1. Исследовать текущую реализацию ссылки "Поделиться" в визуальном редакторе
- [x] 1.2. Определить, куда сейчас переводится пользователь при клике на ссылку
- [x] 1.3. Изучить архитектуру Excalidraw для collaborative editing
- [x] 1.4. Определить стратегию оптимизации для 50-100 пользователей

#### Фаза 2: База данных и persistence
- [x] 1.5. Создать миграцию PostgreSQL для таблицы `liveshare_sessions`
  - Поля: id, diagram_id (FK), owner_id (FK), name, password_hash, max_users
  - Поля: is_active, yjs_state (snapshot), created_at, updated_at, ended_at
  - Индексы на diagram_id, owner_id, is_active
- [x] 1.6. Создать миграцию PostgreSQL для таблицы `liveshare_participants`
  - Поля: id, session_id (FK), user_id (FK), username, joined_at, left_at
  - Индексы на session_id, user_id
- [x] 1.7. Создать Rust модель `LiveShareSession` в `src/core/db/models.rs`
- [x] 1.8. Создать Rust модель `LiveShareParticipant` в `src/core/db/models.rs`
- [x] 1.9. Создать `LiveShareRepository` в `src/core/db/repositories/liveshare.rs`
  - Метод create_session с проверкой прав доступа к диаграмме
  - Метод get_active_session_for_diagram
  - Метод check_session_access (проверка прав пользователя)
  - Метод save_snapshot (периодическое сохранение Yjs state)
  - Метод add_participant / remove_participant

#### Фаза 3: Разделение типов сообщений
- [x] 1.10. Создать enum `WsMessageType` для разных типов сообщений
  - INIT - полная инициализация схемы при подключении
  - UPDATE - инкрементальные изменения (таблицы, колонки, связи)
  - CURSOR_MOVE - позиции курсоров (volatile, можно терять)
  - IDLE_STATUS - статус активности пользователя
  - USER_VIEWPORT - viewport bounds для follow mode
- [x] 1.11. Разделить WebSocket события на critical и non-critical каналы
- [x] 1.12. Реализовать volatile broadcasts для cursor updates (можно терять пакеты)

#### Фаза 4: Инкрементальные обновления
- [x] 1.13. Добавить `version: u64` поле в `SchemaElement` структуру
  - Добавлено в `TableSnapshot` и `RelationshipSnapshot`
- [x] 1.14. Создать `BroadcastManager` для отслеживания отправленных версий элементов
  - HashMap для хранения element_id -> last_broadcasted_version
  - Логика отправки только измененных элементов
  - Полностью протестирован (13 тестов)
- [x] 1.15. Реализовать инкрементальные updates (отправка только изменений)
  - `broadcast_incremental_update()` отправляет только измененные элементы
  - Отслеживание версий для каждого пользователя
- [x] 1.16. Реализовать периодический full sync каждые 20 секунд
  - Автоматическая проверка через `needs_full_sync()`
  - Настраиваемый интервал через `BroadcastManager::with_interval()`
- [x] 1.17. Обработка INIT сообщения для новых подключений (отправка полной схемы)
  - `send_full_graph_state()` для новых пользователей
  - Автоматическая регистрация в `add_user()`

#### Фаза 5: Throttling и оптимизация
- [x] 1.18. Реализовать throttling для cursor updates (33ms = ~30fps)
- [x] 1.19. Реализовать throttling для схемы updates (100-300ms)
- [x] 1.20. Создать `CursorBroadcaster` с защитой от спама
- [x] 1.21. Реализовать batching для awareness updates (собирать 100ms, отправлять батчом)
- [x] 1.22. Добавить rate limiting на уровне WebSocket connection

#### Фаза 6: Reconciliation алгоритм
- [x] 1.23. Создать функцию `reconcile_elements` для слияния локальных и удаленных изменений
- [x] 1.24. Реализовать стратегию разрешения конфликтов (last-write-wins на основе version)
- [x] 1.25. Добавить timestamp-based conflict resolution для одинаковых версий
- [x] 1.26. Обработка удаленных элементов (soft delete с tombstones)
- [x] 1.27. Тестирование reconciliation при одновременном редактировании

#### Фаза 7: Периодические snapshots
- [x] 1.28. Создать фоновую задачу для сохранения snapshot каждые 20-30 секунд
- [x] 1.29. Реализовать сериализацию SchemaGraph в BYTEA для PostgreSQL
- [x] 1.30. Добавить логику восстановления из snapshot при подключении
- [ ] 1.31. Реализовать fallback на Firebase/S3 для больших snapshot (опционально)
- [x] 1.32. Добавить очистку старых snapshots (keep last 10)

#### Фаза 8: Проверка прав доступа и безопасность
- [x] 1.33. Интегрировать LiveShare с системой прав доступа к диаграммам
- [x] 1.34. Проверка прав при создании сессии (только owner/editor)
- [x] 1.35. Проверка прав при подключении к сессии (viewer+)
- [x] 1.36. Добавить связь room_id ↔ diagram_id в таблице sessions
- [x] 1.37. Реализовать автоматическое закрытие сессии при удалении диаграммы
- [x] 1.38. Добавить rate limiting для предотвращения DDoS

#### Фаза 9: Исправление ссылки "Поделиться"
- [x] 1.39. Изменить формат ссылки с `/?room=uuid` на `/editor/{diagram_id}?room=uuid`
- [x] 1.40. Обновить функцию генерации ссылки в `settings_modal.rs` (copy_link)
- [x] 1.41. Обновить отображение ссылки в UI (input field с room link)
- [x] 1.42. Обновить функцию в `liveshare_panel.rs` (если используется)
- [x] 1.43. Обработка параметра `?room=uuid` в EditorPage при загрузке
- [x] 1.44. Автоматическое подключение к сессии при переходе по ссылке

#### Фаза 10: UI индикаторы и UX
- [x] 1.45. Добавить индикатор статуса синхронизации (Syncing/Synced/Error)
- [x] 1.46. Показывать количество активных пользователей в сессии
- [x] 1.47. Добавить индикатор "кто сейчас редактирует" (цветные аватары)
- [x] 1.48. Реализовать тултипы с именами пользователей при наведении на курсоры
- [x] 1.49. Добавить уведомление при потере соединения с восстановлением
- [x] 1.50. Показывать индикатор сохранения snapshot в БД

#### Фаза 11: Idle detection
- [x] 1.51. Реализовать детектор активности пользователя (mousemove, keypress)
- [x] 1.52. Добавить таймауты: IDLE (30 сек бездействия), AWAY (скрыта вкладка)
- [x] 1.53. Транслировать idle статус другим пользователям
- [x] 1.54. Визуально отличать активных/idle/away пользователей
- [ ] 1.55. Автоотключение от сессии после 10 минут AWAY (опционально)

#### Фаза 12: Тестирование и оптимизация
- [x] 1.56. Нагрузочное тестирование с 10 пользователями
- [x] 1.57. Нагрузочное тестирование с 50 пользователями
- [x] 1.58. Нагрузочное тестирование с 100 пользователями
- [x] 1.59. Измерить bandwidth usage и latency
- [x] 1.60. Профилирование CPU и memory usage на сервере
- [x] 1.61. Оптимизация горячих путей (если найдены bottlenecks)
- [x] 1.62. Тестирование сценариев с плохим интернетом (packet loss, high latency)

#### Фаза 13: Документация и мониторинг
- [x] 1.63. Добавить логирование всех критических операций
- [x] 1.64. Добавить метрики (Prometheus/Grafana): активные сессии, пользователи, bandwidth
- [x] 1.65. Создать документацию по архитектуре LiveShare
- [x] 1.66. Документировать протокол WebSocket сообщений
- [x] 1.67. Создать troubleshooting guide для типичных проблем

### 2. Проблемы с LiveShare синхронизацией
**Проблема:** LiveShare работает с критическими ошибками синхронизации

#### 2.1. Локальные таблицы сохраняются при подключении к сессии
**Подзадача:** Все таблицы что пользователь создал локально, при подключении к LiveShare сессии сохраняются

**Детали:**
- [ ] 2.1.1. Исследовать механизм подключения к LiveShare сессии
- [ ] 2.1.2. Определить, где происходит мерж локального и удаленного состояния
- [ ] 2.1.3. Реализовать очистку локальных таблиц перед подключением к сессии
- [ ] 2.1.4. Добавить предупреждение пользователю о потере локальных данных (опционально)
- [ ] 2.1.5. Протестировать сценарий: создание локальных таблиц → подключение к сессии

#### 2.2. Нестабильная синхронизация таблиц
**Подзадача:** Иногда таблицы не синхронизируются, синхронизируются с другим именем и подобные кривые баги с синхронизацией

**Решение:** Принудительная синхронизация схем между всеми пользователями сессии

**Детали:**
- [ ] 2.2.1. Аудит текущей логики синхронизации таблиц
- [ ] 2.2.2. Определить причины несинхронизации (конфликты, race conditions, т.д.)
- [ ] 2.2.3. Реализовать механизм принудительной синхронизации схем
- [ ] 2.2.4. Добавить синхронизацию при каждом изменении схемы
- [ ] 2.2.5. Реализовать синхронизацию при подключении нового пользователя к сессии
- [ ] 2.2.6. Добавить механизм разрешения конфликтов (например, last-write-wins или timestamp-based)
- [ ] 2.2.7. Добавить индикатор статуса синхронизации в UI
- [ ] 2.2.8. Протестировать одновременное редактирование несколькими пользователями
- [ ] 2.2.9. Протестировать переименование таблиц
- [ ] 2.2.10. Протестировать удаление таблиц

## Средний приоритет

### 3. Иконки в поиске таблиц
**Проблема:** Иконки в поиске таблиц заходят на плейсхолдер (перекрываются с placeholder текстом)

**Подзадачи:**
- [ ] 3.1. Найти компонент поиска таблиц в коде
- [ ] 3.2. Проверить CSS стили для иконок и placeholder
- [ ] 3.3. Исправить padding/margin для правильного расположения иконки
- [ ] 3.4. Убедиться, что иконка не перекрывает текст ввода
- [ ] 3.5. Протестировать на разных размерах экрана

### 4. Иконка сохранения исходного кода
**Проблема:** Иконка сохранения source кода не подходит (не соответствует действию)

**Подзадачи:**
- [ ] 4.1. Найти текущую иконку сохранения в Source Code режиме
- [ ] 4.2. Выбрать более подходящую иконку (например, floppy disk, check mark, download)
- [ ] 4.3. Заменить иконку в коде
- [ ] 4.4. Убедиться, что новая иконка визуально понятна
- [ ] 4.5. Проверить accessibility (alt text, aria-label)

### 5. Миграция диалогов создания на HTML `<dialog>`
**Проблема:** Диалоги создания нужно вывести в HTML тег `<dialog>`

**Подзадачи:**
- [ ] 5.1. Найти все диалоги создания (Create Table, Create Column, и т.д.)
- [ ] 5.2. Изучить текущую реализацию диалогов (вероятно custom modal компоненты)
- [ ] 5.3. Создать базовый компонент на основе `<dialog>` элемента
- [ ] 5.4. Реализовать методы `.showModal()` и `.close()`
- [ ] 5.5. Добавить поддержку backdrop стилей через `::backdrop` pseudo-element
- [ ] 5.6. Мигрировать диалог создания таблицы
- [ ] 5.7. Мигрировать диалог создания колонки
- [ ] 5.8. Мигрировать другие диалоги создания (если есть)
- [ ] 5.9. Убедиться в правильной работе Esc key для закрытия
- [ ] 5.10. Проверить accessibility (focus management, ARIA)

### 6. Миграция всех диалогов на HTML `<dialog>`
**Проблема:** Все остальные диалоги нужно тоже вывести в тег `<dialog>`, с помощью него можно упростить некоторую лишнюю логику

**Подзадачи:**
- [ ] 6.1. Составить полный список всех диалогов в приложении
- [ ] 6.2. Определить диалоги, которые еще не мигрированы (после задачи #5)
- [ ] 6.3. Мигрировать диалог подтверждения удаления
- [ ] 6.4. Мигрировать диалог настроек/settings
- [ ] 6.5. Мигрировать диалог ошибок (если есть)
- [ ] 6.6. Мигрировать диалог LiveShare/подключения к сессии
- [ ] 6.7. Удалить старую кастомную логику модальных окон
- [ ] 6.8. Упростить state management для диалогов
- [ ] 6.9. Стандартизировать стили для всех диалогов
- [ ] 6.10. Протестировать все диалоги на корректную работу

### 7. Переключатель Visual Editor / Source Code
**Проблема:** Переключатель между Visual editor и Source код надо вынести на canvas из sidebar, чтобы пользователь видел изменения там, где он нажимал и не бегал глазами туда-сюда

**Подзадачи:**
- [ ] 7.1. Найти текущее расположение переключателя в sidebar
- [ ] 7.2. Определить оптимальное расположение на canvas (вероятно top-right corner)
- [ ] 7.3. Создать новый UI компонент для переключателя на canvas
- [ ] 7.4. Реализовать toggle функционал
- [ ] 7.5. Добавить визуальный индикатор активного режима
- [ ] 7.6. Удалить старый переключатель из sidebar
- [ ] 7.7. Добавить плавную анимацию переключения (опционально)
- [ ] 7.8. Убедиться, что переключатель не перекрывает важный контент
- [ ] 7.9. Проверить responsive поведение на разных размерах экрана
- [ ] 7.10. Протестировать UX и собрать feedback

### 8. Проблема с истечением сессий
**Проблема:** Иногда происходит проблема с сессиями. Она просто истекает и не рефрешится

**Подзадачи:**
- [ ] 8.1. Исследовать механизм управления сессиями
- [ ] 8.2. Определить причину истечения сессии (timeout, отсутствие refresh token, и т.д.)
- [ ] 8.3. Проверить, есть ли логика автоматического обновления токенов
- [ ] 8.4. Реализовать механизм автоматического refresh сессии
- [ ] 8.5. Добавить retry логику при неудачном refresh
- [ ] 8.6. Реализовать обработку случая, когда refresh невозможен
- [ ] 8.7. Добавить уведомление пользователю о скором истечении сессии
- [ ] 8.8. Добавить graceful handling при полном истечении сессии
- [ ] 8.9. Сохранять локальные изменения перед истечением сессии (auto-save)
- [ ] 8.10. Протестировать различные сценарии истечения сессии
- [ ] 8.11. Добавить логирование для отладки проблем с сессиями

---

  ## 9. Интеграция тестового окружения для игнорируемых тестов

**Проблема:** В проекте есть 56 игнорируемых тестов (#[ignore]), которые требуют запущенной PostgreSQL базы данных. Они не могут быть запущены в обычном режиме без специальной подготовки окружения.

**Решение:** Настроить автоматизированное окружение для запуска ignored тестов.

**Подзадачи:**
- [ ] 9.1. Создать отдельный .env.test файл с DATABASE_URL для тестирования
- [ ] 9.2. Настроить docker-compose конфигурацию для тестовой БД (отдельный сервис)
- [ ] 9.3. Создать скрипт setup-test-db.sh для инициализации тестовой БД
- [ ] 9.4. Добавить миграции для тестовой БД (fixtures, начальные данные)
- [ ] 9.5. Создать Makefile target: `make test-integration` для запуска ignored тестов
- [ ] 9.6. Добавить GitHub Actions workflow для CI/CD с запуском ignored тестов
- [ ] 9.7. Документировать процесс локального запуска integration тестов в README
- [ ] 9.8. Убедиться в изоляции тестов (cleanup после каждого теста)
- [ ] 9.9. Добавить timeout для долгих тестов (избежать зависания в CI)
- [ ] 9.10. Запустить все 56 ignored тестов и убедиться они проходят

---

## Легенда
- [ ] Не выполнено
- [x] Выполнено
- [~] В процессе
- [!] Заблокировано

## Примечания
- Приоритеты могут быть пересмотрены в процессе работы
- Каждая задача должна включать тестирование перед закрытием
- Рекомендуется создавать отдельные feature branches для каждой основной задачи
