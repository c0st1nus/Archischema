# Архитектура Diagramix

Этот документ описывает архитектуру проекта Diagramix — редактора диаграмм схем баз данных.

## 🎨 Визуальная схема

```
┌─────────────────────────────────────────────────────────────────┐
│                         Browser                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Diagramix (WASM)                       │  │
│  │                                                           │  │
│  │  ┌─────────────────────────────────────────────────┐     │  │
│  │  │           App Component (app.rs)                │     │  │
│  │  │  • Initialization                                │     │  │
│  │  │  • Meta context                                  │     │  │
│  │  │  • Demo graph setup                              │     │  │
│  │  └──────────────────┬──────────────────────────────┘     │  │
│  │                     │                                     │  │
│  │       ┌─────────────┴──────────────┐                     │  │
│  │       │                            │                     │  │
│  │       v                            v                     │  │
│  │  ┌─────────┐                  ┌─────────┐               │  │
│  │  │  core/  │                  │   ui/   │               │  │
│  │  ├─────────┤                  ├─────────┤               │  │
│  │  │ schema  │◄─────────────────┤ canvas  │               │  │
│  │  │         │  uses models     │         │               │  │
│  │  │ • Table │                  │ • Drag  │               │  │
│  │  │ • Column│                  │ • SVG   │               │  │
│  │  │ • Rel.  │                  │ • State │               │  │
│  │  │ • Graph │                  └────┬────┘               │  │
│  │  └─────────┘                       │                    │  │
│  │                                    │ renders            │  │
│  │                                    v                    │  │
│  │                              ┌──────────┐               │  │
│  │                              │  table   │               │  │
│  │                              ├──────────┤               │  │
│  │                              │ • View   │               │  │
│  │                              │ • Column │               │  │
│  │                              │ • Events │               │  │
│  │                              └──────────┘               │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                         Server (SSR)                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Axum + Leptos SSR (main.rs)                  │  │
│  │  • Serves initial HTML                                    │  │
│  │  • Handles hydration script                               │  │
│  │  • Serves static files (CSS, WASM, JS)                    │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘

Data Flow:
  1. Server renders App → HTML
  2. Browser loads HTML + WASM
  3. WASM hydrates → Interactive app
  4. User interacts → Signals update → UI re-renders
```

## Обзор

Diagramix — это full-stack Rust приложение, использующее Leptos фреймворк для создания реактивного UI с поддержкой Server-Side Rendering (SSR) и клиентской гидратации через WebAssembly.

### Основные принципы

1. **Разделение ответственности** — чёткое разделение на бизнес-логику (`core`) и UI (`ui`)
2. **Минимализм зависимостей** — только необходимые библиотеки
3. **Type-safety** — использование строгой типизации Rust для предотвращения ошибок
4. **Реактивность** — использование сигналов Leptos для автоматического обновления UI

## Структура проекта

```
diagramix/
├── src/
│   ├── main.rs           # Серверная точка входа (SSR режим)
│   ├── lib.rs            # Библиотечная точка входа + гидратация
│   ├── app.rs            # Корневой компонент приложения
│   ├── core/             # Бизнес-логика (domain layer)
│   │   ├── mod.rs
│   │   └── schema.rs     # Модели данных схемы БД
│   └── ui/               # UI компоненты (presentation layer)
│       ├── mod.rs
│       ├── canvas.rs     # Холст редактора
│       └── table.rs      # Компонент таблицы
├── style/                # Стили
│   ├── input.css         # Tailwind исходник
│   └── output.css        # Скомпилированный CSS
├── public/               # Статические файлы
├── Cargo.toml            # Rust зависимости
├── package.json          # NPM зависимости (Tailwind)
└── tailwind.config.js    # Конфигурация Tailwind
```

## Модули

### `core/` — Бизнес-логика

Модуль содержит чистую бизнес-логику без зависимостей от UI фреймворков.

#### `schema.rs`

Определяет основные модели данных:

- **`TableNode`** — представление таблицы БД
  - `name: String` — имя таблицы
  - `columns: Vec<Column>` — список колонок
  - `position: (f64, f64)` — координаты на канвасе

- **`Column`** — представление колонки таблицы
  - `name: String` — имя колонки
  - `data_type: String` — тип данных (VARCHAR, INTEGER и т.д.)
  - `is_primary_key: bool` — флаг первичного ключа
  - `is_nullable: bool` — допускает ли NULL
  - `is_unique: bool` — флаг уникальности
  - `default_value: Option<String>` — значение по умолчанию

- **`Relationship`** — представление связи между таблицами
  - `name: String` — имя связи
  - `relationship_type: RelationshipType` — тип связи (1:1, 1:N, N:M)
  - `from_column: String` — колонка источника
  - `to_column: String` — колонка цели

- **`SchemaGraph`** — тип графа для схемы
  - Использует `petgraph::StableGraph<TableNode, Relationship, Directed>`
  - Узлы — таблицы, рёбра — связи между ними

**Принципы:**
- Модели сериализуемы (derive Serialize, Deserialize)
- Builder pattern для удобного создания (методы `with_*`, `add_*`)
- Не содержит UI логику

### `ui/` — UI компоненты

Модуль содержит Leptos компоненты для визуализации.

#### `canvas.rs` — SchemaCanvas

Главный компонент редактора, отвечает за:

- Отрисовку всех таблиц на канвасе
- Drag & Drop функциональность
- Отрисовку связей между таблицами (SVG)
- Управление глобальным состоянием графа

**Состояние:**
- `graph: RwSignal<SchemaGraph>` — реактивный граф схемы
- `dragging_node: Signal<Option<(NodeIndex, f64, f64)>>` — состояние перетаскивания

**Функциональность:**
- Глобальные обработчики `mousemove` и `mouseup` для drag & drop
- SVG overlay для отрисовки связей стрелками
- Автоматическое отслеживание изменений графа через сигналы

#### `table.rs` — TableNodeView

Компонент для отображения отдельной таблицы:

- Заголовок таблицы (с иконкой перетаскивания)
- Список колонок с индикаторами (PK, NOT NULL, UNIQUE)
- Обработка событий мыши (drag start, context menu)

**Вложенный компонент:**
- `ColumnRow` — строка с информацией о колонке

### `app.rs` — Корневой компонент

Определяет структуру приложения:

- `shell()` — HTML shell для SSR
- `App()` — главный компонент приложения
  - Настройка мета-контекста
  - Подключение стилей
  - Инициализация демо-графа
  - Рендеринг `SchemaCanvas`

## Архитектура данных

### Граф схемы

Используется `petgraph::StableGraph` для представления схемы БД:

```rust
type SchemaGraph = StableGraph<TableNode, Relationship, Directed>;
```

**Преимущества StableGraph:**
- Индексы узлов остаются стабильными при удалении
- Эффективное добавление/удаление узлов и рёбер
- Встроенные алгоритмы для работы с графами

**Структура:**
```
    users (NodeIndex)
      |
      | (EdgeIndex: user_posts, 1:N)
      v
    posts (NodeIndex)
      |
      | (EdgeIndex: post_comments, 1:N)
      v
    comments (NodeIndex)
```

### Реактивность

Используются сигналы Leptos для автоматического обновления UI:

```rust
let graph = RwSignal::new(create_demo_graph());

// При изменении графа UI автоматически обновится
graph.update(|g| {
    if let Some(node) = g.node_weight_mut(node_idx) {
        node.position = (new_x, new_y);
    }
});
```

## Взаимодействие компонентов

```
┌─────────────────────────────────────────┐
│            App (app.rs)                 │
│  - Инициализация графа                  │
│  - Мета-контекст                        │
└───────────────┬─────────────────────────┘
                │
                │ graph: RwSignal<SchemaGraph>
                │
                v
┌─────────────────────────────────────────┐
│       SchemaCanvas (ui/canvas.rs)       │
│  - Drag & Drop логика                   │
│  - Отрисовка связей (SVG)               │
│  - Панель инструментов                  │
└───────────┬─────────────────────────────┘
            │
            │ for each table
            │
            v
┌─────────────────────────────────────────┐
│      TableNodeView (ui/table.rs)        │
│  - Отображение таблицы                  │
│  - Обработка mousedown                  │
│  └─> ColumnRow (columns)                │
└─────────────────────────────────────────┘
```

## Зависимости

### Rust (Cargo.toml)

**Основные:**
- `leptos = "0.8.0"` — реактивный UI фреймворк
- `leptos_meta = "0.8.0"` — управление meta-тегами
- `petgraph = "0.8.3"` — библиотека графов
- `serde = "1.0"` — сериализация/десериализация

**SSR (опциональные):**
- `axum = "0.8.0"` — веб-сервер
- `tokio = "1"` — async runtime
- `leptos_axum = "0.8.0"` — интеграция Leptos + Axum

**WASM (опциональные):**
- `wasm-bindgen = "0.2.105"` — JS биндинги
- `console_error_panic_hook = "0.1"` — отладка в браузере

**Обоснование выбора:**
- ❌ Удалён `uuid` — не нужен, используются индексы графа
- ❌ Удалён `leptos-use` — не использовался
- ❌ Удалён `leptos_router` — приложение на одной странице

### NPM (package.json)

- `tailwindcss = "3.4.18"` — утилитарный CSS

**Обоснование:**
- ❌ Удалён `autoprefixer` — не нужен для современных браузеров
- ❌ Удалён `postcss` — не используется без плагинов
- ❌ Удалён SCSS — избыточная абстракция

## Фичи Leptos

### SSR + Hydration

1. **SSR** (Server-Side Rendering) — генерация HTML на сервере
2. **Hydration** — активация интерактивности на клиенте через WASM

```rust
// Сервер (main.rs)
cargo leptos watch --features ssr

// Клиент (lib.rs)
#[wasm_bindgen]
pub fn hydrate() {
    leptos::mount::hydrate_body(App);
}
```

### Реактивные сигналы

```rust
// RwSignal — read/write сигнал
let graph = RwSignal::new(create_demo_graph());

// Чтение (автоматически подписывается)
let g = graph.get();

// Запись (триггерит обновление)
graph.update(|g| { /* modify */ });
```

### Эффекты

```rust
Effect::new(move || {
    let dragging = dragging_node.get();
    // Код выполняется при изменении dragging_node
});
```

## Будущие улучшения

### Архитектурные

1. **Разделение состояния**
   - Вынести управление графом в отдельный "store"
   - Использовать контекст Leptos для глобального состояния

2. **Команды (Command pattern)**
   - Реализовать undo/redo через command pattern
   - История изменений графа

3. **Модульность UI**
   - Toolbar компонент для добавления таблиц
   - Properties panel для редактирования свойств
   - Context menu для операций с таблицами

### Функциональные

1. **Персистентность**
   - Сохранение в localStorage
   - Экспорт/импорт JSON

2. **Экспорт SQL**
   - Генерация DDL для разных СУБД
   - Миграции (diff между схемами)

3. **Визуализация**
   - Zoom/Pan канваса
   - Автоматическое расположение таблиц (graph layout algorithms)
   - Связи от конкретных колонок (не от центра таблицы)

## Производительность

### Оптимизация WASM

Профиль `wasm-release` в `Cargo.toml`:
```toml
[profile.wasm-release]
inherits = "release"
opt-level = 'z'      # Оптимизация по размеру
lto = true           # Link-time optimization
codegen-units = 1    # Лучшая оптимизация
panic = "abort"      # Меньший размер
```

### Реактивность

- Используются `RwSignal` вместо отдельных `ReadSignal`/`WriteSignal`
- Минимизация ререндеров через гранулярную реактивность Leptos
- `collect_view()` для эффективного рендеринга списков

## Тестирование

### Юнит-тесты

```bash
cargo test
```

Тестировать можно:
- Создание моделей (`TableNode`, `Column`, `Relationship`)
- Операции с графом (добавление узлов/рёбер)
- Builder методы

### Интеграционные тесты

В будущем можно добавить:
- E2E тесты с Playwright
- Визуальные регрессионные тесты

## Заключение

Архитектура Diagramix построена на принципах:
- **Простота** — минимум зависимостей и абстракций
- **Типобезопасность** — использование системы типов Rust
- **Реактивность** — автоматическое обновление UI
- **Модульность** — чёткое разделение на слои

Это обеспечивает хорошую базу для дальнейшего развития проекта.